#!/usr/bin/env ruby

require 'optparse'
require 'time'
require 'iron_worker_ng'

class IronWorkerCLILoggerFormatter < ::Logger::Formatter
  def call(severity, time, proname, msg)
    msg + "\n"
  end
end

@env = nil

def create_client
  client = IronWorkerNG::Client.new(:env => @env)

  project = client.projects.get
  
  IronCore::Logger.info 'IronWorkerNG', "Working with project '#{project.name}' ('#{project.id}')"

  client
end

def env_opt(opts)
  opts.on('-e', '--env ENV', 'environment') do |v|
    @env = v
  end
end

if $*.size == 1 && ($*[0] == '-v' || $*[0] == '--version')
  puts IronWorkerNG.full_version
  exit 0
end

if $*.size == 0 || (not ['upload', 'queue', 'schedule', 'log', 'run'].include?($*[0]))
  puts 'usage: iron_worker COMMAND [OPTIONS]'
  puts '    COMMAND: upload, queue, schedule, log, run'
  puts '    run iron_worker COMMAND --help to get more information about each command'
  exit 1
end

command = $*.shift

IronCore::Logger.logger.formatter = IronWorkerCLILoggerFormatter.new

if $*.include?('--debug')
  IronCore::Logger.logger.level = ::Logger::DEBUG

  $*.reject! { |p| p == '--debug' }
end

if command == 'upload'
  if $*.size > 0 && $*[0][0] != '-'
    $*.unshift('-n')
  end

  name = nil
  options = {}

  opts = OptionParser.new do |opts|
    opts.banner = "usage: iron_worker #{command} [OPTIONS]"

    opts.on('-n', '--name NAME', 'code name or workerfile') do |v|
      name = v
    end

    opts.on('-c', '--max-concurrency CONCURRENCY', Integer, 'max number of concurrent workers for this code package') do |v|
      options[:max_concurrency] = v
    end

    env_opt(opts)
  end

  begin
    opts.parse!
  rescue OptionParser::ParseError
    puts $!.to_s
    exit 1
  end

  if name.nil?
    puts opts
    exit 1
  end

  client = create_client

  code = IronWorkerNG::Code::Base.new(name)
  
  IronCore::Logger.info 'IronWorkerNG', "Worker '#{code.name}' upload started"
  
  client.codes.create(code, options)

  IronCore::Logger.info 'IronWorkerNG', "Worker '#{code.name}' uploaded"
elsif command == 'queue' || command == 'schedule'
  if $*.size > 0 && $*[0][0] != '-'
    $*.unshift('-n')
  end

  name = nil
  payload = nil
  payload_file = nil

  priority = nil
  timeout = nil
  delay = nil

  start_at = nil
  end_at = nil
  run_times = nil
  run_every = nil

  print_id = false

  opts = OptionParser.new do |opts|
    opts.banner = "usage: iron_worker #{command} [OPTIONS]"

    opts.on('-n', '--name NAME', 'code name') do |v|
      name = v
    end

    opts.on('-p', '--payload PAYLOAD', String, 'payload to pass') do |v|
      payload = v
    end

    opts.on('-f', '--payload-file PAYLOAD_FILE', String, 'payload file to pass') do |v|
      payload_file = v
    end

    opts.on('--priority PRIORITY', Integer, '0 (default), 1, 2') do |v|
      priority = v
    end

    opts.on('--timeout TIMEOUT', Integer, 'maximum run time in seconds from 0 to 3600 (default)') do |v|
      timeout = v
    end

    opts.on('--delay DELAY', Integer, 'delay before start in seconds') do |v|
      delay = v
    end

    if command == 'schedule'
      opts.on('--start-at TIME', 'start task at specified time') do |v|
        start_at = Time.parse(v)
      end

      opts.on('--end-at TIME', 'stop running task at specified time') do |v|
        end_at = Time.parse(v)
      end

      opts.on('--run-times RUN_TIMES', Integer, 'run task no more times than specified') do |v|
        run_times = v
      end

      opts.on('--run-every RUN_EVERY', Integer, 'run task every RUN_EVERY seconds') do |v|
        run_every = v
      end
    end

    opts.on('--print-id', 'prints result id') do |v|
      print_id = true
    end

    env_opt(opts)
  end

  begin
    opts.parse!
  rescue OptionParser::ParseError
    puts $!.to_s
    exit 1
  end

  if name.nil?
    puts opts
    exit 1
  end

  if payload.nil? and (not payload_file.nil?)
    payload = File.read(payload_file)
  end

  options = {}

  options[:priority] = priority unless priority.nil?
  options[:timeout] = timeout unless timeout.nil?
  options[:delay] = delay unless delay.nil?

  if command == 'schedule'
    options[:start_at] = start_at unless start_at.nil?
    options[:end_at] = end_at unless end_at.nil?
    options[:run_times] = run_times unless run_times.nil?
    options[:run_every] = run_every unless run_every.nil?
  end

  client = create_client

  id = nil

  if command == 'queue'
    id = client.tasks.create(name, payload, options).id

    IronCore::Logger.info 'IronWorkerNG', "Worker '#{name}' queued"
  else
    id = client.schedules.create(name, payload, options).id

    IronCore::Logger.info 'IronWorkerNG', "Worker '#{name}' scheduled"
  end

  puts id if print_id
elsif command == 'log'
  if $*.size > 0 && $*[0][0] != '-'
    $*.unshift('-t')
  end

  task_id = nil
  live = false
  wait = false

  opts = OptionParser.new do |opts|
    opts.banner = "usage: iron_worker #{command} [OPTIONS]"

    opts.on('-t', '--task-id ID', 'task id') do |v|
      task_id = v
    end

    opts.on('-w', '--wait', 'wait for task') do |v|
      wait = true
    end

    env_opt(opts)
  end

  begin
    opts.parse!
  rescue OptionParser::ParseError
    puts $!.to_s
    exit 1
  end

  if task_id.nil?
    puts opts
    exit 1
  end

  client = create_client

  log = ''

  if live
    begin
      log = client.tasks.log(task_id)
    rescue IronCore::Error
    end
  else
    if wait
      client.tasks.wait_for(task_id)
    end

    log = client.tasks.log(task_id)
  end

  print log

  if live
    client.tasks.wait_for(task_id) do |task|
      if task.status == 'running'
        begin
          next_log = client.tasks.log(task_id)
          print next_log[log.length .. - 1]
          log = next_log
        rescue IronCore::Error
        end
      end
    end

    begin
      next_log = client.tasks.log(task_id)
      print next_log[log.length .. - 1]
    rescue IronCore::Error
    end
  end
elsif command == 'run'
  if $*.size > 0 && $*[0][0] != '-'
    $*.unshift('-n')
  end

  name = nil
  payload = nil
  payload_file = nil

  opts = OptionParser.new do |opts|
    opts.banner = "usage: iron_worker #{command} [OPTIONS]"

    opts.on('-n', '--name NAME', 'code name or workerfile') do |v|
      name = v
    end

    opts.on('-p', '--payload PAYLOAD', String, 'payload to pass') do |v|
      payload = v
    end

    opts.on('-f', '--payload-file PAYLOAD_FILE', String, 'payload file to pass') do |v|
      payload_file = v
    end
  end

  begin
    opts.parse!
  rescue OptionParser::ParseError
    puts $!.to_s
    exit 1
  end

  if name.nil?
    puts opts
    exit 1
  end

  if payload.nil? and (not payload_file.nil?)
    payload = File.read(payload_file)
  end

  code = IronWorkerNG::Code::Base.new(name)

  IronCore::Logger.info 'IronWorkerNG', "Worker '#{name}' run started"
  
  code.run(payload)
end
